import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import deap.gp as gp
import networkx as nx
from src.operators import OPERATORS  # Import our implementation
from src.trees import Node, ExpressionTree
from itertools import combinations

def plot_3d_function(x, y, best_tree, num_samples):
    """
    Plots the function found by the GP in a 3D graph if the problem has exactly 2 variables.

    :param x: Independent variables (matrix of shape (num_variables, num_samples))
    :param y: Target values
    :param best_tree: Best tree generated by the GP (ExpressionTree)
    :param num_samples: Number of data points
    """
    num_variables = x.shape[0]  # Count the number of independent variables

    if num_variables != 2:
        print("3D plotting is available only for problems with two variables. Skipping...")
        return

    print("Generating 3D plot...")

    # Extract the two independent variables
    x0 = x[0, :]
    x1 = x[1, :]

    # Compute predicted values using the generated tree
    y_pred = best_tree.evaluate(x)

    # Create 3D plot
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')

    # Plot actual values
    ax.scatter(x0, x1, y, color='red', label="Actual Values", alpha=0.5)

    # Plot predicted values
    ax.scatter(x0, x1, y_pred, color='blue', label="GP Predictions", alpha=0.5)

    # Labels
    ax.set_xlabel("X0")
    ax.set_ylabel("X1")
    ax.set_zlabel("Y")
    ax.set_title("3D Visualization of the Function")

    # Change view angle
    elevation_angle = 30  # View height
    rotation_angle = 45   # Rotation around Z-axis
    ax.view_init(elev=elevation_angle, azim=rotation_angle)

    # Show legend
    ax.legend()

    # Display plot
    plt.show()


def build_graph(tree):
    """ Creates a NetworkX graph from an ExpressionTree and returns the graph and root node """
    G = nx.DiGraph()
    counter = [0]  # Reset counter for each call
    
    def _build_graph(node, parent=None):
        node_id = counter[0]
        counter[0] += 1

        G.add_node(node_id, label=str(node.value))

        if parent is not None:
            G.add_edge(parent, node_id)

        for child in node.children:
            _build_graph(child, node_id)

        return node_id  # The first node added is always the root node

    root = _build_graph(tree)  # The first node is always the root
    return G, root  # Root is now guaranteed to be the first inserted node

def plot_expression_tree(expr_tree):
    """
    Plots the syntax tree of an ExpressionTree with optimized spacing.
    """
    G, root = build_graph(expr_tree.root)  # Build the graph and get the root node

    if root not in G:
        print(f"Error: Root node {root} not found in the graph!")
        return

    labels = nx.get_node_attributes(G, 'label')
    pos = hierarchy_pos(G, root=root, width=2.5, vert_gap=0.4)

    operator_nodes = {n for n in G.nodes if labels[n] in OPERATORS}
    leaf_nodes = set(G.nodes) - operator_nodes

    plt.figure(figsize=(12, 8))
    nx.draw_networkx_nodes(G, pos, nodelist=operator_nodes, node_color="lightblue", node_size=2500, edgecolors="black")
    nx.draw_networkx_nodes(G, pos, nodelist=leaf_nodes, node_color="lightgreen", node_size=2000, edgecolors="black")
    nx.draw_networkx_edges(G, pos, edge_color="gray", alpha=0.8)
    nx.draw_networkx_labels(G, pos, labels=labels, font_size=12, font_weight="bold")
    plt.title("Tree Representation of the Best Formula Found", fontsize=14)
    plt.show()

# Hierarchical positioning functions (unchanged)
def hierarchy_pos(G, root=None, width=2., vert_gap=0.3, xcenter=0.5):
    pos = _hierarchy_pos(G, root, width, vert_gap, xcenter)
    return pos

def _hierarchy_pos(G, root, width=2., vert_gap=0.3, xcenter=0.5, pos=None, parent=None, level=0):
    if pos is None:
        pos = {root: (xcenter, 1 - level * vert_gap)}
    else:
        pos[root] = (xcenter, 1 - level * vert_gap)
        
    children = list(G.neighbors(root))
    if not isinstance(G, nx.DiGraph):
        G = G.to_directed()
    
    if len(children) != 0:
        dx = width / max(len(children), 1)
        nextx = xcenter - width / 2 - dx / 2
        for child in children:
            nextx += dx
            pos = _hierarchy_pos(G, child, width=dx, vert_gap=vert_gap, xcenter=nextx, pos=pos, parent=root, level=level + 1)
    
    return pos

def plot_multiple_3d(x, y, best_tree, num_samples):
    """
    Plots 3D graphs for all possible combinations of variable pairs,
    splitting them into windows with a maximum of 5 plots per window.

    :param x: Independent variables (matrix of shape (num_variables, num_samples))
    :param y: Target values
    :param best_tree: Best tree generated by the GP (ExpressionTree)
    :param num_samples: Number of data points
    """
    num_variables = x.shape[0]  # Number of independent variables

    if num_variables < 2:
        print("At least 2 variables are required for 3D plotting. Skipping...")
        return

    print("Generating 3D plots for all variable combinations...")

    # Generate all possible combinations of variable pairs
    var_combinations = list(combinations(range(num_variables), 2))
    num_plots = len(var_combinations)

    # Compute predicted values once
    y_pred = best_tree.evaluate(x)

    # Divide the plots into groups of max 5 per window
    max_plots_per_window = 5
    for start_idx in range(0, num_plots, max_plots_per_window):
        end_idx = min(start_idx + max_plots_per_window, num_plots)
        current_combinations = var_combinations[start_idx:end_idx]

        cols = 3  # Number of columns in subplots
        rows = (len(current_combinations) + cols - 1) // cols  # Compute the number of required rows

        fig, axes = plt.subplots(rows, cols, figsize=(6 * cols, 5 * rows), subplot_kw={'projection': '3d'})
        axes = axes.flatten()  # Flatten the axis array for easy access

        for i, (var_x, var_y) in enumerate(current_combinations):
            ax = axes[i]

            # Selected variables
            x0 = x[var_x, :]
            x1 = x[var_y, :]

            # Plot actual values
            ax.scatter(x0, x1, y, color='red', label="Actual Values", alpha=0.5)

            # Plot predicted values
            ax.scatter(x0, x1, y_pred, color='blue', label="GP Predictions", alpha=0.5)

            # Labels
            ax.set_xlabel(f"X{var_x}")
            ax.set_ylabel(f"X{var_y}")
            ax.set_zlabel("Y")
            ax.set_title(f"Plot {start_idx + i + 1}: X{var_x} vs X{var_y}")

            # Change view angle
            ax.view_init(elev=30, azim=45)

            # Legend
            ax.legend()

        # Remove any empty subplots
        for j in range(i + 1, len(axes)):
            fig.delaxes(axes[j])

        plt.tight_layout()
        plt.show()
